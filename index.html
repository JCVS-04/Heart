<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <!-- Etiqueta para dise√±o responsivo -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Animaci√≥n de Corazones</title>
  <style>
    /* Estilos generales */
    body {
      margin: 0;
      background: linear-gradient(45deg, #1e1e1e, #0a0a0a);
      color: #fff;
      font-family: 'Arial', sans-serif;
      text-align: center;
    }
    /* Encabezado superior */
    header {
      padding: 20px;
      background-color: #ff69b4;
      font-size: 2em;
      font-weight: bold;
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.6);
    }
    /* Contenedor de la animaci√≥n */
    #animation-container {
      position: relative;
      overflow: hidden;
    }
    /* El canvas se adapta al ancho del contenedor */
    canvas {
      display: block;
      margin: 0 auto;
      width: 100%;
      max-width: 1200px;
      height: auto;
      background: black; /* Por si el redimensionado deja √°reas sin dibujar */
    }
    /* Secci√≥n de frases o poemas */
    #poems {
      padding: 20px;
      font-size: 1.2em;
      line-height: 1.6;
    }
    /* Media queries para dispositivos m√≥viles */
    @media (max-width: 600px) {
      header {
        font-size: 1.5em;
      }
      #poems {
        font-size: 1em;
      }
    }
  </style>
</head>
<body>
  <!-- Encabezado con el mensaje -->
  <header>
    TE AMO MILKA <span>üòçü•∞üòò</span>
  </header>

  <!-- Contenedor de la animaci√≥n -->
  <div id="animation-container">
    <!-- Canvas de la animaci√≥n -->
    <canvas id="canvas" width="1200" height="700"></canvas>
  </div>

  <!-- Secci√≥n de frases o poemas -->
  <div id="poems">
    <p>"En cada latido, mi coraz√≥n susurra tu nombre..."</p>
    <p>"Tus ojos son estrellas que iluminan mi noche..."</p>
    <p>"El amor es un viaje sin destino, pero contigo, cada paso es poes√≠a."</p>
  </div>

  <script>
    // Obtiene el canvas y el contexto 2D
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    // Funci√≥n para adaptar el canvas al ancho del contenedor (responsividad)
    function resizeCanvas() {
      canvas.width = canvas.parentElement.clientWidth;
      canvas.height = 700; // Puedes ajustar el alto si lo deseas
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // Creamos un arreglo de 200 objetos con posici√≥n inicial
    const totalObjects = 200;
    const objects = [];
    for (let i = 0; i < totalObjects; i++) {
      // Inicialmente, los objetos se posicionan en (500, 250) (estos valores se reubicar√°n al reiniciar)
      objects.push({ x: 500, y: 250, color: "#fff", char: '‚òÜ' });
    }

    // Variables para controlar el objeto actual y el car√°cter que se muestra
    let num = 0;
    let currentChar = '‚òÜ';
    const chars = ['‚û§', '‚ô•', '‚òÜ', '‚óâ', '‚ûπ', '‚òº', '‚ùã', '‚ò∫', '‚ô™'];

    // Usamos requestAnimationFrame para una animaci√≥n m√°s fluida
    let lastUpdateTime = 0;
    function update(timestamp) {
      if (!lastUpdateTime) lastUpdateTime = timestamp;
      const delta = timestamp - lastUpdateTime;
      if (delta > 100) { // Actualizamos aproximadamente cada 100ms
        for (let t = 0; t < totalObjects; t++) {
          // Calcula el desplazamiento usando f√≥rmulas que generan la forma de un "coraz√≥n"
          const xp = -Math.floor(16 * Math.pow(Math.sin(t), 3));
          const yp = -Math.floor(13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));
          
          // Genera un color aleatorio con componentes rojo y azul (verde en 0)
          const r = Math.floor(Math.random() * (255 - 100 + 1)) + 100;
          const b = Math.floor(Math.random() * (255 - 100 + 1)) + 100;
          const color = `rgb(${r},0,${b})`;

          // Actualiza el objeto actual sumando el desplazamiento
          objects[num].x += xp;
          objects[num].y += yp;
          objects[num].color = color;
          objects[num].char = currentChar;

          // Si la posici√≥n X supera un cierto porcentaje del ancho del canvas, reinicia las posiciones
          if (objects[num].x >= canvas.width * 0.66) {
            // Cambia el car√°cter actual aleatoriamente
            currentChar = chars[Math.floor(Math.random() * chars.length)];
            // Reinicia la posici√≥n de todos los objetos (aproximadamente centrados)
            for (let s = 0; s < totalObjects; s++) {
              objects[s].x = canvas.width * 0.433;
              objects[s].y = canvas.height * 0.386;
            }
          }

          // Pasa al siguiente objeto (ciclo circular)
          num = (num + 1) % totalObjects;
        }
        lastUpdateTime = timestamp;
      }
      drawObjects();
      requestAnimationFrame(update);
    }

    // Funci√≥n para dibujar todos los objetos en el canvas
    function drawObjects() {
      // Limpia el canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Dibuja un fondo negro
      ctx.fillStyle = "black";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Configura la fuente y a√±ade una sombra para mayor dinamismo
      ctx.font = "24px Arial";
      ctx.shadowColor = "rgba(0, 0, 0, 0.5)";
      ctx.shadowBlur = 4;

      // Dibuja cada objeto (texto) en su posici√≥n, con su color y car√°cter
      for (let i = 0; i < totalObjects; i++) {
        const obj = objects[i];
        ctx.fillStyle = obj.color;
        ctx.fillText(obj.char, obj.x, obj.y);
      }
    }

    // Inicia la animaci√≥n
    requestAnimationFrame(update);
  </script>
</body>
</html>
